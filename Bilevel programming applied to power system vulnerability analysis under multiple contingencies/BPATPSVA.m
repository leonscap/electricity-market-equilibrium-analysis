% Bilevel Programming applied to Power System Vulnerability analysis under Multiple Contingencies
%
%   For more detali, refer to the IET Gener. Transm. Distrib.
%   ulr: https://digital-library.theiet.org/content/journals/10.1049/iet-gtd.2009.0098
%   doi: 10.1049/iet-gtd.2009.0098
%
clc; clear; close all;

%% Define Constant
ng = 33;                % number of generators
nl = 38;                % number of lines
nb = 24;                % number of buses

%% Network Topology
% load system data
case24_ieee_rts;

% bus-gen connection matrix
gbus = gen(:, 1);
Cg   = sparse(gbus, 1:ng, 1, nb, ng);

% line-bus connection matrix
fbus = branch(:, 1);
tbus = branch(:, 2);
i    = [(1:nl)'; (1:nl)'];
Cft  = sparse(i, [fbus; tbus], [ones(nl, 1); -ones(nl, 1)], nl, nb);
Cf   = sparse((1:nl)', fbus, ones(nl, 1), nl, nb);
Ct   = sparse((1:nl)', tbus, ones(nl, 1), nl, nb);

%% Load Data
K        = 2;               % pre-specified maximum number of simultaneous out-of-service lines
PHI_SPEC = 200;             % pre-specified threshold of system load shed (MW)
PD       = load;            % demand at bus (MW)
F_MAX    = branch(:, 4);    % power flow capacity of line (MW)
PG_MAX   = gen(:, 2);       % capacity of generator (MW)
PG_MIN   = gen(:, 3);       % minimum power output of generator (MW)
B        = branch(:, 3);    % susceptance of line (S)

%% Define Variable
% primal variable
v          = binvar(nl, 1, 'full'); % 0/1 variable which is equal to 0 if line is out of service and otherwise equal to 1
% v          = ones(nl, 1);
% v([25,26,28]) = 0;

delta      = sdpvar(nb, 1, 'full'); % phase angle at bus (rad)
pg         = sdpvar(ng, 1, 'full'); % power output of generator (MW)
f          = sdpvar(nl, 1, 'full'); % power flow of line (MW)
ps         = sdpvar(nb, 1, 'full'); % load shed at bus (MW)

% dual variable
mu         = sdpvar(nl, 1, 'full'); % LM associated with the equation relating power flow and phase angle (p.u.)
lambda     = sdpvar(nb, 1, 'full'); % LM associated with the power balance equation at bus (p.u.)
omegaLB    = sdpvar(nl, 1, 'full'); % LM associated with the lower bound for the power flow of line (p.u.)
omegaUB    = sdpvar(nl, 1, 'full'); % LM associated with the upper bound for the power flow of line (p.u.)
thetaLB    = sdpvar(ng, 1, 'full'); % LM associated with the lower bound for the power output of generator (p.u.)
thetaUB    = sdpvar(ng, 1, 'full'); % LM associated with the upper bound for the power output of generator (p.u.)
alphaLB    = sdpvar(nb, 1, 'full'); % LM associated with the lower bound for the load shed at bus (p.u.)
alphaUB    = sdpvar(nb, 1, 'full'); % LM associated with the upper bound for the load shed at bus (p.u.)
xiLB       = sdpvar(nb, 1, 'full'); % LM associated with the lower bound for the phase angle at bus (MW)
xiUB       = sdpvar(nb, 1, 'full'); % LM associated with the upper bound for the phase angle at bus (MW)
xi1        = sdpvar(nb, 1, 'full'); % LM associated with the phase angle at slack bus (MW)
xi1(2:end, 1) = 0;

% auxiliary variable
auxfLB     = binvar(nl, 1, 'full'); % binary variable for the CP (F_MAX + f) * omegaLB = 0
auxfUB     = binvar(nl, 1, 'full'); % binary variable for the CP (F_MAX - f) * omegaUB = 0
auxpgLB    = binvar(ng, 1, 'full'); % binary variable for the CP (pg - PG_MIN) * thetaLB = 0
auxpgUB    = binvar(ng, 1, 'full'); % binary variable for the CP (PG_MAX - pg) * thetaUB = 0
auxpsLB    = binvar(nb, 1, 'full'); % binary variable for the CP ps * alphaLB = 0
auxpsUB    = binvar(nb, 1, 'full'); % binary variable for the CP (PD - ps) * alphaUB = 0
auxdeltaLB = binvar(nb, 1, 'full'); % binary variable for the CP (pi + delta) * xiLB = 0
auxdeltaUB = binvar(nb, 1, 'full'); % binary variable for the CP (pi - delta) * xiUB = 0

zFR        = sdpvar(nl, 1, 'full'); % represent v * deltaFR (rad)
zTO        = sdpvar(nl, 1, 'full'); % represent v * deltaTO (rad)
sFR        = sdpvar(nl, 1, 'full'); % auxiliary variable for zFR = Cf * delta - sFR (rad)
sTO        = sdpvar(nl, 1, 'full'); % auxiliary variable for zTO = Ct * delta - sTO (rad)
t          = sdpvar(nl, 1, 'full'); % represent v * mu (p.u.)
b          = sdpvar(nl, 1, 'full'); % auxiliary variable for t = mu - b (p.u.)

%% Lower-level Reformulation
% constant used for linearization
deltaLB_LIN = -2*pi;        % lower bound for the nodal phase angle (rad)
deltaUB_LIN =  2*pi;        % upper bound for the nodal phase angle (rad)
muLB_LIN    = -1e+3;        % lower bound for mu (p.u.)
muUB_LIN    =  1e+3;        % upper bound for mu (p.u.)

fLB_LIN     = 2*F_MAX + 1;  % upper bound for F_MAX + f (MW)
fUB_LIN     = 2*F_MAX + 1;  % upper bound for F_MAX - f (MW)
pgLB_LIN    = PG_MAX + 1;   % upper bound for pg - PG_MIN (MW)
pgUB_LIN    = PG_MAX + 1;   % upper bound for PG_MAX - pg (MW)
psLB_LIN    = PD + 1;       % upper bound for ps (MW)
psUB_LIN    = PD + 1;       % upper bound for PD - ps (MW)

omegaLB_LIN = 1e+3;         % upper bound for omegaLB (p.u.)
omegaUB_LIN = 1e+3;         % upper bound for omegaUB (p.u.)
thetaLB_LIN = 1e+3;         % upper bound for thetaLB (p.u.)
thetaUB_LIN = 1e+3;         % upper bound for thetaUB (p.u.)
alphaLB_LIN = 1e+3;         % upper bound for alphaLB (p.u.)
alphaUB_LIN = 1e+3;         % upper bound for alphaUB (p.u.)
xiLB_LIN    = 1e+3;         % upper bound for xiLB (MW)
xiUB_LIN    = 1e+3;         % upper bound for xiUB (MW)

% primal constraint
constP = [];
% constP = [constP, (f == diag(B.*v) * Cft * delta): '(5)'];
constP = [constP, (f == B .* (zFR - zTO)): '(54)'];
constP = [constP, (zFR == Cf * delta - sFR): '(55)'];
constP = [constP, (zTO == Ct * delta - sTO): '(56)'];
constP = [constP, (deltaLB_LIN .* v <= zFR <= deltaUB_LIN .* v): '(57)'];
constP = [constP, (deltaLB_LIN .* v <= zTO <= deltaUB_LIN .* v): '(58)'];
constP = [constP, (deltaLB_LIN .* (1 - v) <= sFR <= deltaUB_LIN .* (1 - v)): '(59)'];
constP = [constP, (deltaLB_LIN .* (1 - v) <= sTO <= deltaUB_LIN .* (1 - v)): '(60)'];
constP = [constP, (Cg * pg - Cft' * f + ps == PD): '(6)'];
constP = [constP, (-F_MAX <= f <= F_MAX): '(7)'];
constP = [constP, (PG_MIN <= pg <= PG_MAX): '(8)'];
constP = [constP, (0 <= ps <= PD): '(9)'];
constP = [constP, (-pi <= delta <= pi): 'phase angle bound'];
constP = [constP, (delta(1,1) == 0): 'slack bus'];

% dual constraint
constD = [];
% constD = [constD, (Cft' * diag(B) * (mu.*v) - xiLB + xiUB - xi1 == 0): '(61)'];
constD = [constD, (Cft' * diag(B) * t - xiLB + xiUB - xi1 == 0): '(71)'];
constD = [constD, (t == mu - b): '(72)'];
constD = [constD, (muLB_LIN .* v <= t <= muUB_LIN .* v): '(73)'];
constD = [constD, (muLB_LIN .* (1 - v) <= b <= muUB_LIN .* (1 - v)): '(74)'];
constD = [constD, (-Cg' * lambda - thetaLB + thetaUB == 0): '(62)'];
constD = [constD, (Cft * lambda - mu - omegaLB + omegaUB == 0): '(63)'];
constD = [constD, (1 - lambda - alphaLB + alphaUB == 0): '(64)'];
constD = [
    constD, ...
    (omegaLB >= 0): '(65)', (omegaUB >= 0): '(66)', ...
    (thetaLB >= 0): '(67)', (thetaUB >= 0): '(68)', ...
    (alphaLB >= 0): '(69)', (alphaUB >= 0): '(70)', ...
    (xiLB >= 0): 'xiLB >= 0', (xiUB >= 0): 'xiUB >= 0';
];

% complementarity slackness condition
constCP = [];
constCP = [constCP, (omegaLB <= omegaLB_LIN .* auxfLB): '(81)'];
constCP = [constCP, (f + F_MAX <= fLB_LIN .* (1 - auxfLB)): '(82)'];
constCP = [constCP, (omegaUB <= omegaUB_LIN .* auxfUB): '(83)'];
constCP = [constCP, (F_MAX - f <= fUB_LIN .* (1 - auxfUB)): '(84)'];
constCP = [constCP, (thetaLB <= thetaLB_LIN .* auxpgLB): '(85)'];
constCP = [constCP, (pg - PG_MIN <= pgLB_LIN .* (1 - auxpgLB)): '(86)'];
constCP = [constCP, (thetaUB <= thetaUB_LIN .* auxpgUB): '(87)'];
constCP = [constCP, (PG_MAX - pg <= pgUB_LIN .* (1 - auxpgUB)): '(88)'];
constCP = [constCP, (alphaLB <= alphaLB_LIN .* auxpsLB): '(89)'];
constCP = [constCP, (ps <= psLB_LIN .* (1 - auxpsLB)): '(90)'];
constCP = [constCP, (alphaUB <= alphaUB_LIN .* auxpsUB): '(91)'];
constCP = [constCP, (PD - ps <= psUB_LIN .* (1 - auxpsUB)): '(92)'];
constCP = [constCP, (xiLB <= xiLB_LIN .* auxdeltaLB): 'upper bound for xiLB'];
constCP = [constCP, (pi + delta <= (2*pi) .* (1 - auxdeltaLB)): 'upper bound for pi + delta'];
constCP = [constCP, (xiUB <= xiUB_LIN .* auxdeltaUB): 'upper bound for xiUB'];
constCP = [constCP, (pi - delta <= (2*pi) .* (1 - auxdeltaUB)): 'upper bound for pi - delta'];

constYA = [];
constYA = [constYA, (complements(F_MAX + f >= 0, omegaLB >= 0)): '(81)-(82)'];
constYA = [constYA, (complements(F_MAX - f >= 0, omegaUB >= 0)): '(83)-(84)'];
constYA = [constYA, (complements(pg - PG_MIN >= 0, thetaLB >= 0)): '(85)-(86)'];
constYA = [constYA, (complements(PG_MAX - pg >= 0, thetaUB >= 0)): '(87)-(88)'];
constYA = [constYA, (complements(ps >= 0, alphaLB >= 0)): '(89)-(90)'];
constYA = [constYA, (complements(PD - ps >= 0, alphaUB >= 0)): '(91)-(92)'];
constYA = [constYA, (complements(pi + delta >= 0, xiLB >= 0)): '(pi + delta) * xiLB = 0'];
constYA = [constYA, (complements(pi - delta >= 0, xiUB >= 0)): '(pi - delta) * xiUB = 0'];

constBL = [];
constBL = [constBL, ((F_MAX + f) .* omegaLB == 0): '(81)-(82)'];
constBL = [constBL, ((F_MAX - f) .* omegaUB == 0): '(83)-(84)'];
constBL = [constBL, ((pg - PG_MIN) .* thetaLB == 0): '(85)-(86)'];
constBL = [constBL, ((PG_MAX - pg) .* thetaUB == 0): '(87)-(88)'];
constBL = [constBL, (ps .* alphaLB == 0): '(89)-(90)'];
constBL = [constBL, ((PD - ps) .* alphaUB == 0): '(91)-(92)'];
constBL = [constBL, ((pi + delta) .* xiLB == 0): '(pi + delta) * xiLB = 0'];
constBL = [constBL, ((pi - delta) .* xiUB == 0): '(pi - delta) * xiUB = 0'];

% strong duality equality
constSD = [(sum(ps, 'all') == sum((lambda - alphaUB) .* PD, 'all') - sum((omegaLB + omegaUB) .* F_MAX, 'all') + ...
    sum(thetaLB .* PG_MIN, 'all') - sum(thetaUB .* PG_MAX, 'all') - pi * sum(xiLB, 'all') - pi * sum(xiUB, 'all')): '(99)'];

%% Debugging
fixv = ones(nl, 1);
fixv([25 26 28]) = 0;

% solve the primal problem
objP = sum(ps, 'all'); % minimize the system load
optsP = sdpsettings('solver', 'gurobi', 'verbose', 0);
disgP = optimize([constP, v == fixv], objP, optsP);

% solve the dual problem
objD = sum((lambda - alphaUB) .* PD, 'all') - sum((omegaLB + omegaUB) .* F_MAX, 'all') ...
    + sum(thetaLB .* PG_MIN, 'all') - sum(thetaUB .* PG_MAX, 'all') - pi * sum(xiLB, 'all') - pi * sum(xiUB, 'all');
optsD = sdpsettings('solver', 'gurobi', 'verbose', 0);
disgD = optimize([constD, v == fixv], -objD, optsD);

% solve the KKT optimality condition
% constKKT = [constP, constD, constCP];
% constKKT = [constP, constD, constYA];
constKKT = [constP, constD, constBL];
optsKKT = sdpsettings('solver', 'gurobi', 'verbose', 0);
diagsKKT = optimize([constKKT, v == fixv], [], optsKKT);

% solve the strong duality system
constSD = [constP, constD, constSD];
optsSD = sdpsettings('solver', 'gurobi', 'verbose', 0);
diagsSD = optimize([constSD, v == fixv], [], optsSD);

%% Minimum Vulnerability Model
objMIN   = sum(1 - v, 'all');       % minimize the number of out-of-service lines
constUL  = [(sum(ps, 'all') >= PHI_SPEC): '(2)'];
constLL  = [constP, constD, constSD];
constMIN = [constUL, constLL];
optsMIN  = sdpsettings('solver', 'gurobi', 'verbose', 0);
diagMIN  = optimize(constMIN, objMIN, optsMIN);

valzFR = all(deltaLB_LIN < value(zFR) < deltaUB_LIN, 'all');
valzTO = all(deltaLB_LIN < value(zTO) < deltaUB_LIN, 'all');
valsFR = all(deltaLB_LIN < value(sFR) < deltaUB_LIN, 'all');
valsTO = all(deltaLB_LIN < value(sTO) < deltaUB_LIN, 'all');
valt   = all(muLB_LIN < value(t) < muUB_LIN, 'all');
valb   = all(muLB_LIN < value(b) < muUB_LIN, 'all');

if ~all([valzFR valzTO valsFR valsTO valt valb])
    disp('Invalid bounds for linearizing binary variable product continuous variable');
end

%% Maximum Vulnerability Model
objMAX   = sum(ps, 'all');          % maximize the system load shed
constUL  = [(sum(1 - v, 'all') <= K): '(11)'];
constLL  = [constP, constD, constSD];
constMAX = [constUL, constLL];
optsMAX  = sdpsettings('solver', 'gurobi', 'verbose', 0);
diagMAX  = optimize(constMAX, -objMAX, optsMAX);

valzFR = all(deltaLB_LIN < value(zFR) < deltaUB_LIN, 'all');
valzTO = all(deltaLB_LIN < value(zTO) < deltaUB_LIN, 'all');
valsFR = all(deltaLB_LIN < value(sFR) < deltaUB_LIN, 'all');
valsTO = all(deltaLB_LIN < value(sTO) < deltaUB_LIN, 'all');
valt   = all(muLB_LIN < value(t) < muUB_LIN, 'all');
valb   = all(muLB_LIN < value(b) < muUB_LIN, 'all');

if ~all([valzFR valzTO valsFR valsTO valt valb])
    disp('Invalid bounds for linearizing binary variable product continuous variable');
end

disp('Done!');